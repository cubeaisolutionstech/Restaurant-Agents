<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Voice Conversation AI - Complete Chat</title>
  <style>
    /* Professional Business Theme */
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      max-width: 900px;
      margin: 20px auto;
      padding: 20px;
      background: #f6f8fa;
      color: #253858;
      min-height: 100vh;
    }
    .container {
      background: #fff;
      border-radius: 24px;
      padding: 36px;
      box-shadow: 0 8px 32px rgba(37, 56, 88, 0.08);
      border: 2px solid #253858;
    }
    h1 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.7rem;
      color: #1a2940;
      font-weight: 800;
      letter-spacing: 1px;
      text-shadow: 0 2px 8px rgba(37, 56, 88, 0.08);
    }
    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 30px;
    }
    button { 
      padding: 15px 25px; 
      border-radius: 50px; 
      border: none; 
      cursor: pointer; 
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      background: linear-gradient(90deg, #1a2940 0%, #253858 100%);
      color: #fff;
    }
    button:hover {
      background: #f4b400;
      color: #253858;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    .status {
      text-align: center;
      font-size: 18px;
      margin: 20px 0;
      padding: 15px;
      border-radius: 20px;
      background: #253858;
      color: #fff;
      border: 1px solid #f4b400;
    }
    .listening {
      animation: pulse 1.5s infinite;
      background: rgba(96, 111, 132, 0.3) !important;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }
    .log { 
      margin-top: 20px; 
      padding: 20px;
      background: #fff;
      color: #253858;
      border-radius: 20px;
      border: 1px solid #253858;
      max-height: 400px;
      overflow-y: auto;
      line-height: 1.6;
    }
    .message {
      margin: 15px 0;
      padding: 10px 15px;
      border-radius: 15px;
      word-wrap: break-word;
    }
    .user-message {
      background: #f6f8fa;
      color: #253858;
      border: 1px solid #f4b400;
      margin-left: 20px;
      border-bottom-right-radius: 5px;
    }
    .ai-message {
      background: #253858;
      color: #fff;
      border: 1px solid #f4b400;
      margin-right: 20px;
      border-bottom-left-radius: 5px;
    }
    .voice-settings {
      margin: 20px 0;
      padding: 15px;
      background: #4a5d7c;
      color: #fff;
      border-radius: 20px;
      border: 1px solid #f4b400;
    }
    .voice-settings label {
      display: block;
      margin: 10px 0 5px 0;
      font-weight: bold;
      color: #f4b400;
    }
    .voice-settings select, .voice-settings input {
      width: 100%;
      padding: 8px;
      border-radius: 8px;
      border: 1px solid #f4b400;
      background: #fff;
      color: #253858;
      margin-bottom: 10px;
      font-weight: 600;
    }
    .voice-settings option {
      background: #333;
      color: white;
    }
    
    /* Confirmation Modal Styles */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      z-index: 9999;
      backdrop-filter: blur(8px);
      overflow-y: auto;
    }
    
    .confirmation-modal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 20px;
      padding: 35px;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
      max-width: 550px;
      width: 90%;
      color: white;
      border: 3px solid rgba(255, 255, 255, 0.3);
      min-height: 400px;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .modal-title {
      font-size: 1.8rem;
      text-align: center;
      margin-bottom: 20px;
      color: #fff;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .reservation-details {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 25px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .detail-item {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      font-size: 1.1rem;
    }
    
    .detail-item:last-child {
      border-bottom: none;
    }
    
    .detail-label {
      font-weight: bold;
      color: #e0e0e0;
    }
    
    .detail-value {
      color: #fff;
      text-align: right;
      max-width: 60%;
      word-wrap: break-word;
    }
    
    .payment-status {
      background: rgba(255, 193, 7, 0.2);
      border-radius: 8px;
      padding: 12px 15px !important;
      border: 1px solid rgba(255, 193, 7, 0.3);
      margin-top: 10px;
    }
    
    .pending-status {
      color: #FFC107;
      font-weight: bold;
      background: rgba(255, 193, 7, 0.2);
      padding: 4px 12px;
      border-radius: 15px;
      font-size: 0.95rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .modal-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
    }
    
    .modal-button {
      padding: 12px 25px;
      border: none;
      border-radius: 25px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 120px;
    }
    
    .confirm-btn {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
    }
    
    .confirm-btn:hover {
      background: linear-gradient(45deg, #45a049, #4CAF50);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
    }
    
    .edit-btn {
      background: linear-gradient(45deg, #ff9800, #f57c00);
      color: white;
    }
    
    .edit-btn:hover {
      background: linear-gradient(45deg, #f57c00, #ff9800);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 152, 0, 0.4);
    }
    
    .modal-overlay.show {
      display: block;
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .confirmation-modal.show {
      animation: slideIn 0.3s ease;
    }
    
    @keyframes slideIn {
      from {
        transform: translate(-50%, -60%);
        opacity: 0;
      }
      to {
        transform: translate(-50%, -50%);
        opacity: 1;
      }
    }
    
    @keyframes pulse {
      0% { 
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.02);
        box-shadow: 0 30px 90px rgba(0, 0, 0, 0.6);
      }
      100% { 
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé§ MML Restaurant Booking System</h1>
    
    <!-- Enhanced Instructions -->
    <div style="background: rgba(255, 255, 255, 0.1); border-radius: 15px; padding: 20px; margin-bottom: 20px; text-align: center;">
      <h3 style="margin-bottom: 10px;">üí¨ How to Book:</h3>
      <p style="margin: 5px 0;"><strong>üöÄ One-Paragraph Booking:</strong> "I'd like to book a table for John Smith, tomorrow at 7 PM for 4 people"</p>
      <p style="margin: 5px 0;"><strong>üìù Step-by-Step:</strong> I'll guide you through each detail individually</p>
      <p style="margin: 5px 0; font-size: 14px; opacity: 0.8;">The system automatically detects if you provide complete details!</p>
    </div>
    
    <div class="voice-settings">
      <label for="voiceSelect">üîä AI Voice:</label>
      <select id="voiceSelect"></select>
      <button id="testVoice">üîä Test Voice</button>
      
      <label for="speedRange">‚ö° Speech Speed:</label>
      <input type="range" id="speedRange" min="0.5" max="2" step="0.1" value="1">
      
      <label for="pitchRange">üéµ Voice Pitch:</label>
      <input type="range" id="pitchRange" min="0" max="2" step="0.1" value="1">
    </div>

    <div class="controls">
      <button id="micTest">üé§ Test Microphone</button>
      <button id="start">üé§ Make Reservation</button>
      <button id="stop" disabled>‚èπÔ∏è End Call</button>
      <button id="clear">üóëÔ∏è Clear Chat</button>
    </div>

    <div class="status" id="status">Welcome to MML Restaurant! You can speak all your booking details at once or I'll guide you step-by-step. Click "Make Reservation" to start!</div>

    <div class="log" id="log"></div>
  </div>

  <!-- Confirmation Modal -->
  <div class="modal-overlay" id="confirmationModal">
    <div class="confirmation-modal">
      <h2 class="modal-title">üçΩÔ∏è Confirm Your Reservation</h2>
      
      <div class="reservation-details" id="reservationDetails">
        <div class="detail-item">
          <span class="detail-label">üë§ Name:</span>
          <span class="detail-value" id="confirmName">--</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">üìÖ Date:</span>
          <span class="detail-value" id="confirmDate">--</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">üïê Time:</span>
          <span class="detail-value" id="confirmTime">--</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">üë• Party Size:</span>
          <span class="detail-value" id="confirmMembers">--</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">üìù Special Requests:</span>
          <span class="detail-value" id="confirmSpecial">None</span>
        </div>
        <div class="detail-item payment-status">
          <span class="detail-label">üí≥ Payment Status:</span>
          <span class="detail-value pending-status" id="confirmPayment">Pending</span>
        </div>
      </div>
      
      <div class="modal-buttons">
        <button class="modal-button edit-btn" id="editReservation">‚úèÔ∏è Edit Details</button>
        <button class="modal-button confirm-btn" id="finalConfirm">‚úÖ Confirm Reservation</button>
      </div>
    </div>
  </div>

  <script>
    let recognition;
    let isListening = false;
    let voices = [];
    let conversationHistory = [];
    
    // MML Restaurant Reservation System
    let reservationStep = 0;
    let customerData = {
      name: null,
      date: null,
      time: null,
      members: null,
      specialRequests: null,
      paymentStatus: 'Pending'
    };

    // MongoDB Integration Configuration
    const MONGODB_CONFIG = {
      apiUrl: 'http://localhost:3000/api/reservations', // Your MongoDB API endpoint
      databaseName: 'mml_restaurant',
      collectionName: 'reservations'
    };

    // Function to save reservation to MongoDB
    const saveReservationToMongoDB = async (reservationData) => {
      try {
        console.log('üíæ Saving reservation to MongoDB:', reservationData);
        
        // Prepare data for MongoDB
        const dataToSave = {
          timestamp: new Date().toISOString(),
          name: reservationData.name || '',
          date: reservationData.date || '',
          time: reservationData.time || '', 
          members: reservationData.members || '',
          specialRequests: reservationData.specialRequests || 'None',
          paymentStatus: reservationData.paymentStatus || 'Pending',
          confirmation: `MML-${Date.now()}`, // Generate unique confirmation number
          status: 'Confirmed',
          createdAt: new Date(),
          restaurantLocation: 'MML Restaurant Main Branch',
          source: 'Voice Booking System'
        };

        // Save to MongoDB via API
        const response = await fetch(MONGODB_CONFIG.apiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
          },
          body: JSON.stringify(dataToSave)
        });

        if (response.ok) {
          const result = await response.json();
          console.log('‚úÖ Reservation saved successfully to MongoDB:', result);
          log('‚úÖ Reservation saved to our database!', false);
          return dataToSave.confirmation;
        } else {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

      } catch (error) {
        console.error('‚ùå Error saving to MongoDB:', error);
        log('‚ö†Ô∏è Database temporarily unavailable - reservation recorded locally', false);
        
        // Fallback: Save to localStorage as backup
        saveToLocalStorage(reservationData);
        return `MML-${Date.now()}`;
      }
    };

    // Fallback function to save to localStorage
    const saveToLocalStorage = (reservationData) => {
      const backupData = JSON.parse(localStorage.getItem('mml_reservations') || '[]');
      backupData.push({
        ...reservationData,
        timestamp: new Date().toISOString(),
        confirmation: `MML-${Date.now()}`,
        status: 'Pending Sync to Database',
        createdAt: new Date(),
        needsSync: true
      });
      localStorage.setItem('mml_reservations', JSON.stringify(backupData));
      console.log('üìÅ Reservation saved to local storage as backup');
    };

    // Function to sync offline reservations to MongoDB
    const syncOfflineReservations = async () => {
      const backupData = JSON.parse(localStorage.getItem('mml_reservations') || '[]');
      const pendingReservations = backupData.filter(res => res.needsSync === true);
      
      if (pendingReservations.length > 0) {
        console.log(`üîÑ Syncing ${pendingReservations.length} offline reservations to MongoDB...`);
        
        for (const reservation of pendingReservations) {
          try {
            await saveReservationToMongoDB(reservation);
            reservation.needsSync = false;
            reservation.status = 'Synced to Database';
            console.log(`‚úÖ Synced reservation: ${reservation.confirmation}`);
          } catch (error) {
            console.log(`‚ùå Failed to sync reservation: ${reservation.confirmation}`);
          }
        }
        
        // Update localStorage with synced status
        localStorage.setItem('mml_reservations', JSON.stringify(backupData));
      }
    };

    // Function to display detailed reservation summary
    const showReservationSummary = (data) => {
      const summary = `
üìã RESERVATION SAVED TO DATABASE:
üë§ Name: ${data.name}
üìÖ Date: ${data.date}
üïê Time: ${data.time}
üë• Party Size: ${data.members}
üìù Special Requests: ${data.specialRequests || 'None'}
üí≥ Payment Status: ${data.paymentStatus || 'Pending'}
‚úÖ Status: Confirmed
üé´ Confirmation: ${data.confirmation || 'Generating...'}
üìç Location: MML Restaurant Main Branch
üóÑÔ∏è Database: MongoDB - ${MONGODB_CONFIG.databaseName}
      `;
      console.log(summary);
      log('üìã Reservation details saved to database and logged to console', false);
    };

    // MongoDB API Setup Instructions
    const showMongoDBSetup = () => {
      console.log(`
üóÑÔ∏è MONGODB SETUP INSTRUCTIONS:

1. Install MongoDB and Node.js on your server

2. Create a Node.js API server (server.js):

const express = require('express');
const { MongoClient } = require('mongodb');
const cors = require('cors');

const app = express();
app.use(express.json());
app.use(cors());

const MONGODB_URI = 'mongodb://localhost:27017';
const DB_NAME = 'mml_restaurant';

// POST endpoint to save reservations
app.post('/api/reservations', async (req, res) => {
  try {
    const client = new MongoClient(MONGODB_URI);
    await client.connect();
    
    const db = client.db(DB_NAME);
    const collection = db.collection('reservations');
    
    const result = await collection.insertOne(req.body);
    
    await client.close();
    
    res.json({ 
      success: true, 
      insertedId: result.insertedId,
      confirmation: req.body.confirmation 
    });
  } catch (error) {
    console.error('Database error:', error);
    res.status(500).json({ error: error.message });
  }
});

// GET endpoint to fetch reservations
app.get('/api/reservations', async (req, res) => {
  try {
    const client = new MongoClient(MONGODB_URI);
    await client.connect();
    
    const db = client.db(DB_NAME);
    const collection = db.collection('reservations');
    
    const reservations = await collection.find({}).sort({ createdAt: -1 }).toArray();
    
    await client.close();
    
    res.json(reservations);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(3000, () => {
  console.log('MongoDB API server running on http://localhost:3000');
});

3. Install dependencies:
   npm init -y
   npm install express mongodb cors

4. Start your MongoDB server:
   mongod

5. Start your API server:
   node server.js

6. Your reservations will be saved to MongoDB collection 'reservations'
      `);
    };

    // Call setup instructions on load
    showMongoDBSetup();

    // Reservation conversation steps
    const RESERVATION_STEPS = {
      GREETING: 0,
      NAME: 1,
      DATE: 2, 
      TIME: 3,
      MEMBERS: 4,
      SPECIAL_REQUESTS: 5,
      CONFIRMATION: 6,
      COMPLETE: 7
    };
    
    // Enhanced voice loading with error handling
    function loadVoices() {
      try {
        voices = speechSynthesis.getVoices();
        const voiceSelect = document.getElementById('voiceSelect');
        
        if (!voiceSelect) {
          console.error('Voice select element not found');
          return;
        }
        
        voiceSelect.innerHTML = '';
        
        if (voices.length === 0) {
          const option = document.createElement('option');
          option.value = -1;
          option.textContent = 'Loading voices...';
          voiceSelect.appendChild(option);
          
          // Try again after a delay
          setTimeout(loadVoices, 100);
          return;
        }
        
        voices.forEach((voice, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = `${voice.name} (${voice.lang})`;
          
          // PRIORITY SELECTION: Female voices first
          const isFemaleVoice = voice.name.toLowerCase().includes('female') ||
            voice.name.toLowerCase().includes('woman') ||
            voice.name.toLowerCase().includes('sara') ||
            voice.name.toLowerCase().includes('emma') ||
            voice.name.toLowerCase().includes('zira') ||
            voice.name.toLowerCase().includes('hazel') ||
            voice.name.toLowerCase().includes('samantha') ||
            voice.name.toLowerCase().includes('karen') ||
            voice.name.toLowerCase().includes('susan') ||
            voice.name.toLowerCase().includes('anna') ||
            voice.name.toLowerCase().includes('eva');
          
          // Select female voices first, then English high-quality voices
          if (voice.lang.startsWith('en') && (
            isFemaleVoice ||
            voice.name.includes('Google') || 
            voice.name.includes('Microsoft') ||
            voice.name.includes('Natural') ||
            voice.default
          )) {
            option.selected = true;
            option.textContent += ' ‚≠ê RECOMMENDED';
          }
          
          voiceSelect.appendChild(option);
        });
        
        console.log(`Loaded ${voices.length} voices`);
        
      } catch (error) {
        console.error('Error loading voices:', error);
      }
    }

    // Load voices when available
    speechSynthesis.onvoiceschanged = loadVoices;
    loadVoices();

    // Test Selected Voice Function
    const testSelectedVoice = () => {
      const voiceSelect = document.getElementById('voiceSelect');
      const selectedIndex = voiceSelect.value;
      
      if (selectedIndex >= 0 && voices[selectedIndex]) {
        const selectedVoice = voices[selectedIndex];
        log(`üîä Testing voice: ${selectedVoice.name}`, false);
        speakClearly("Hello! I'm your MML Restaurant booking assistant. This is how I sound when taking your reservation. Do you like this voice?");
      } else {
        log('‚ùå Please select a voice first', false);
      }
    };

    // Confirmation Modal Functions
    const showConfirmationModal = (reservationData) => {
      // Fill in the modal with reservation details
      document.getElementById('confirmName').textContent = reservationData.name ;
      document.getElementById('confirmDate').textContent = reservationData.date || '--';
      document.getElementById('confirmTime').textContent = reservationData.time || '--';
      document.getElementById('confirmMembers').textContent = reservationData.members || '--';
      document.getElementById('confirmSpecial').textContent = reservationData.specialRequests || 'None';
      document.getElementById('confirmPayment').textContent = reservationData.paymentStatus || 'Pending';
      
      // Show the modal with animation
      const modal = document.getElementById('confirmationModal');
      const modalContent = modal.querySelector('.confirmation-modal');
      
      modal.classList.add('show');
      modalContent.classList.add('show');
      
      // Stop listening while modal is open
      if (recognition && isListening) {
        recognition.stop();
      }
      
      log('üìã Please review your reservation details in the confirmation window', false);
      speakClearly("Please review your reservation details and click confirm if everything looks correct, or click edit to make changes. Your payment status is currently pending.");
      
      // Add a subtle pulse effect to make modal more noticeable
      setTimeout(() => {
        modalContent.style.animation = 'pulse 2s infinite';
      }, 1000);
    };

    const hideConfirmationModal = () => {
      const modal = document.getElementById('confirmationModal');
      const modalContent = modal.querySelector('.confirmation-modal');
      
      modal.classList.remove('show');
      modalContent.classList.remove('show');
      
      // Restart listening after modal closes
      setTimeout(() => {
        if (isListening) {
          startListening();
        }
      }, 300);
    };

    const handleFinalConfirmation = async () => {
      hideConfirmationModal();
      
      // Save to MongoDB Database
      try {
        const confirmationNumber = await saveReservationToMongoDB(customerData);
        customerData.confirmation = confirmationNumber;
        showReservationSummary(customerData);
        console.log(`‚úÖ Reservation saved to MongoDB with confirmation: ${confirmationNumber}`);
        
        reservationStep = RESERVATION_STEPS.COMPLETE;
        
        const confirmMessage = `Wonderful! Your reservation is confirmed and saved to our database. We'll see you at MML Restaurant on ${customerData.date} at ${customerData.time}. Your confirmation number is ${confirmationNumber}. Payment status is currently pending. We can't wait to serve you! Is there anything else I can help you with?`;
        
        log(confirmMessage, false);
        speakClearly(confirmMessage);
        
      } catch (error) {
        console.error('Error saving reservation:', error);
        
        // Fallback confirmation
        const confirmationNumber = `MML-${Date.now()}`;
        customerData.confirmation = confirmationNumber;
        reservationStep = RESERVATION_STEPS.COMPLETE;
        
        const fallbackMessage = `Your reservation is confirmed with confirmation number ${confirmationNumber}. There was a temporary issue with our database, but your reservation has been recorded locally and will be synced automatically.`;
        
        log(fallbackMessage, false);
        speakClearly(fallbackMessage);
      }
    };

    const handleEditReservation = () => {
      hideConfirmationModal();
      
      // Reset to start over
      reservationStep = RESERVATION_STEPS.NAME;
      customerData = { name: null, date: null, time: null, members: null, specialRequests: null, paymentStatus: 'Pending' };
      
      const editMessage = "No problem! Let's start over with your reservation. May I have your name please?";
      log(editMessage, false);
      speakClearly(editMessage);
    };

    // Enhanced logging function
    const log = (message, isUser = false) => {
      const logDiv = document.getElementById("log");
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${isUser ? 'user-message' : 'ai-message'}`;
      messageDiv.innerHTML = `<strong>${isUser ? 'üë§ You:' : 'ü§ñ AI:'}</strong> ${message}`;
      logDiv.appendChild(messageDiv);
      logDiv.scrollTop = logDiv.scrollHeight;
      
      // Add to conversation history
      conversationHistory.push({
        role: isUser ? 'user' : 'assistant',
        content: message,
        timestamp: new Date().toISOString()
      });
    };

    // Enhanced speak function with voice settings and error handling
    const speak = (text) => {
      if (!('speechSynthesis' in window)) {
        console.warn('Speech synthesis not supported');
        log('üîá Text-to-speech not supported in this browser', false);
        return;
      }
      
      try {
        // Stop any current speech
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        
        // Apply voice settings safely
        const voiceSelect = document.getElementById('voiceSelect');
        const selectedVoiceIndex = voiceSelect ? voiceSelect.value : 0;
        if (voices && voices[selectedVoiceIndex]) {
          utterance.voice = voices[selectedVoiceIndex];
        }
        
        const speedRange = document.getElementById('speedRange');
        const pitchRange = document.getElementById('pitchRange');
        
        utterance.rate = speedRange ? parseFloat(speedRange.value) : 1;
        utterance.pitch = pitchRange ? parseFloat(pitchRange.value) : 1;
        utterance.volume = 0.9;
        
        // Add speech events
        utterance.onstart = () => {
          const statusEl = document.getElementById('status');
          if (statusEl) {
            statusEl.textContent = 'üó£Ô∏è AI is speaking...';
            statusEl.className = 'status';
          }
        };
        
        utterance.onend = () => {
          const statusEl = document.getElementById('status');
          if (isListening && statusEl) {
            statusEl.textContent = 'üéß Listening for your response...';
            statusEl.className = 'status listening';
            setTimeout(() => startListening(), 100);
          } else if (statusEl) {
            statusEl.textContent = 'Ready to chat!';
            statusEl.className = 'status';
          }
        };
        
        utterance.onerror = (e) => {
          console.error('Speech synthesis error:', e);
          const statusEl = document.getElementById('status');
          if (statusEl) {
            statusEl.textContent = 'Speech error occurred - continuing without voice';
            statusEl.className = 'status';
          }
          // Continue without voice if speech fails
          if (isListening) {
            setTimeout(() => startListening(), 200);
          }
        };
        
        speechSynthesis.speak(utterance);
        
      } catch (error) {
        console.error('Speech synthesis error:', error);
        log('üîá Voice output failed, continuing with text only', false);
        
        // Continue the conversation even if speech fails
        if (isListening) {
          const statusEl = document.getElementById('status');
          if (statusEl) {
            statusEl.textContent = 'üéß Listening (voice output disabled)...';
            statusEl.className = 'status listening';
          }
          setTimeout(() => startListening(), 200);
        }
      }
    };

    // ENHANCED Speech Function - Crystal Clear AI Voice
    const speakClearly = (text) => {
      if (!('speechSynthesis' in window)) {
        console.warn('Speech synthesis not supported');
        log('üîá Text-to-speech not supported in this browser', false);
        return;
      }
      
      try {
        // Stop any current speech IMMEDIATELY
        speechSynthesis.cancel();
        
        const utterance = new SpeechSynthesisUtterance(text);
        
        // GUARANTEED FEMALE voice selection - always choose a working voice
        const voiceSelect = document.getElementById('voiceSelect');
        const selectedVoiceIndex = voiceSelect ? voiceSelect.value : 0;
        
        // ENSURE we have voices loaded
        if (!voices || voices.length === 0) {
          voices = speechSynthesis.getVoices();
        }
        
        // SMART voice selection with FEMALE preference
        if (voices && voices.length > 0) {
          let bestVoice = null;
          
          // Priority 1: Try selected voice from dropdown
          if (selectedVoiceIndex >= 0 && voices[selectedVoiceIndex]) {
            bestVoice = voices[selectedVoiceIndex];
          }
          
          // Priority 2: Find FEMALE voices (contains common female voice names)
          if (!bestVoice) {
            const femaleVoices = voices.filter(voice => 
              voice.name.toLowerCase().includes('female') ||
              voice.name.toLowerCase().includes('woman') ||
              voice.name.toLowerCase().includes('sara') ||
              voice.name.toLowerCase().includes('emma') ||
              voice.name.toLowerCase().includes('zira') ||
              voice.name.toLowerCase().includes('hazel') ||
              voice.name.toLowerCase().includes('samantha') ||
              voice.name.toLowerCase().includes('karen') ||
              voice.name.toLowerCase().includes('susan') ||
              voice.name.toLowerCase().includes('anna') ||
              voice.name.toLowerCase().includes('eva')
            );
            
            if (femaleVoices.length > 0) {
              bestVoice = femaleVoices[0];
            }
          }
          
          // Priority 3: High-quality voices (Google/Microsoft)
          if (!bestVoice) {
            const highQualityVoices = voices.filter(voice => 
              voice.name.includes('Google') || 
              voice.name.includes('Microsoft') || 
              voice.name.includes('Neural') ||
              voice.name.includes('Natural')
            );
            
            if (highQualityVoices.length > 0) {
              bestVoice = highQualityVoices[0];
            }
          }
          
          // Priority 4: Any English voice
          if (!bestVoice) {
            const englishVoices = voices.filter(voice => voice.lang.startsWith('en'));
            if (englishVoices.length > 0) {
              bestVoice = englishVoices[0];
            }
          }
          
          // Priority 5: Default to first available voice
          if (!bestVoice) {
            bestVoice = voices[0];
          }
          
          utterance.voice = bestVoice;
          console.log(`üîä Using voice: ${bestVoice.name} (${bestVoice.lang})`);
        }
        
        // OPTIMAL settings for FEMALE restaurant booking voice
        utterance.rate = 0.85;    // Slightly slower for elegant feminine clarity
        utterance.pitch = 1.1;    // Higher pitch for natural feminine tone
        utterance.volume = 1.0;   // Maximum volume
        
        // Override with user preferences if available
        const speedRange = document.getElementById('speedRange');
        const pitchRange = document.getElementById('pitchRange');
        if (speedRange) utterance.rate = parseFloat(speedRange.value) * 0.9;
        if (pitchRange) utterance.pitch = parseFloat(pitchRange.value);
        
        // ENHANCED speech events for seamless conversation
        utterance.onstart = () => {
          const statusEl = document.getElementById('status');
          if (statusEl) {
            statusEl.textContent = 'üó£Ô∏è MML Restaurant speaking clearly...';
            statusEl.className = 'status';
          }
        };
        
        utterance.onend = () => {
          // IMMEDIATE return to listening - CONTINUOUS conversation
          if (isListening) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
              statusEl.textContent = 'üéß Ready to hear you - Please speak naturally...';
              statusEl.className = 'status listening';
            }
            // NO delays - instant listening
            setTimeout(() => {
              if (isListening && recognition) {
                try {
                  recognition.start();
                } catch (e) {
                  console.log('Recognition continues automatically');
                }
              }
            }, 50);
          }
        };
        
        utterance.onerror = (e) => {
          console.error('Speech synthesis error:', e);
          // NEVER stop listening even if speech fails
          if (isListening) {
            const statusEl = document.getElementById('status');
            if (statusEl) {
              statusEl.textContent = 'üéß Continuing to listen...';
              statusEl.className = 'status listening';
            }
            setTimeout(() => {
              if (isListening && recognition) {
                try {
                  recognition.start();
                } catch (e) {
                  console.log('Recognition continues despite voice error');
                }
              }
            }, 50);
          }
        };
        
        // Speak with enhanced clarity
        speechSynthesis.speak(utterance);
        
      } catch (error) {
        console.error('Enhanced speech synthesis error:', error);
        log('üîá Voice output failed, continuing with text only', false);
        
        // ALWAYS continue the conversation
        if (isListening) {
          const statusEl = document.getElementById('status');
          if (statusEl) {
            statusEl.textContent = 'üéß Ready to continue - Please speak...';
            statusEl.className = 'status listening';
          }
          setTimeout(() => {
            if (isListening && recognition) {
              try {
                recognition.start();
              } catch (e) {
                console.log('Recognition continues in text mode');
              }
            }
          }, 50);
        }
      }
    };

    // ENHANCED: Extract ALL reservation details from one paragraph
    const extractCompleteReservation = (input) => {
      console.log('üîç Analyzing complete reservation input:', input);
      
      const reservationData = {
        name: null,
        date: null,
        time: null,
        members: null,
        specialRequests: null
      };
      
      // Extract name - look for common patterns in one paragraph
      const namePatterns = [
        /(?:my name is|i'm|i am|this is|call me|name's|under the name|name)\s+([a-zA-Z][a-zA-Z\s]{1,30})/i,
        /(?:reservation for|table for|booking for)\s+([a-zA-Z][a-zA-Z\s]{1,30})(?:\s+(?:on|at|for|today|tomorrow))/i,
        /^([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2})(?:\s+(?:would like|wants|needs|for))/i
      ];
      
      for (const pattern of namePatterns) {
        const match = input.match(pattern);
        if (match) {
          const potentialName = match[1].trim();
          if (!potentialName.match(/\b(reservation|table|book|today|tomorrow|restaurant|want|need|time|date|people|person|dinner|lunch)\b/i) && potentialName.length >= 2) {
            reservationData.name = potentialName;
            break;
          }
        }
      }
      
      // Extract date with enhanced patterns
      reservationData.date = extractDate(input);
      
      // Extract time with enhanced patterns  
      reservationData.time = extractTime(input);
      
      // Extract members/party size with enhanced patterns
      const memberPatterns = [
        /(?:table for|party of|for)\s+(\d+)(?:\s+(?:people|persons|guests|members|pax))?/i,
        /(\d+)\s+(?:people|persons|guests|members|pax)/i,
        /(?:we are|there are|group of)\s+(\d+)/i,
        /(\d+)\s+(?:of us|in our party|in our group)/i,
        // Word numbers
        /(?:table for|party of|for)\s+(one|two|three|four|five|six|seven|eight|nine|ten)(?:\s+(?:people|persons|guests))?/i,
        /(one|two|three|four|five|six|seven|eight|nine|ten)\s+(?:people|persons|guests|members)/i
      ];
      
      for (const pattern of memberPatterns) {
        const match = input.match(pattern);
        if (match) {
          let members = match[1];
          // Convert word numbers to digits
          const wordToNumber = {
            'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
            'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10
          };
          
          if (wordToNumber[members.toLowerCase()]) {
            members = wordToNumber[members.toLowerCase()];
          } else {
            members = parseInt(members);
          }
          
          if (members >= 1 && members <= 20) {
            reservationData.members = members;
            break;
          }
        }
      }
      
      // Extract special requests - look for dietary, occasion, or seating preferences
      const specialRequestPatterns = [
        /(?:special request|dietary|allergy|allergic to|vegetarian|vegan|gluten free|celebration|celebrating|birthday|anniversary|window seat|quiet table|booth|wheelchair|accessibility)[\s\w,.]*/i,
        /(?:we are celebrating|it's our|it's my|special occasion)[\s\w,.]*/i,
        /(?:prefer|would like|need)[\s\w,.]*(?:seat|table|booth|view|quiet|private)[\s\w,.]*/i
      ];
      
      for (const pattern of specialRequestPatterns) {
        const match = input.match(pattern);
        if (match) {
          reservationData.specialRequests = match[0].trim();
          break;
        }
      }
      
      // If no specific special requests found, extract any remaining details
      if (!reservationData.specialRequests) {
        // Look for additional context that might be special requests
        const words = input.toLowerCase().split(/[\s,.!?]+/);
        const specialWords = ['vegetarian', 'vegan', 'allergy', 'birthday', 'anniversary', 'celebration', 'wheelchair', 'quiet', 'window', 'booth', 'private'];
        
        if (words.some(word => specialWords.includes(word))) {
          // Find sentence containing special words
          const sentences = input.split(/[.!?]+/);
          for (const sentence of sentences) {
            if (specialWords.some(word => sentence.toLowerCase().includes(word))) {
              reservationData.specialRequests = sentence.trim();
              break;
            }
          }
        }
      }
      
      console.log('üìä Extracted reservation data:', reservationData);
      return reservationData;
    };

    // MML Restaurant Booking AI Response Generator - ENHANCED for One-Paragraph Input
    const generateAIResponse = (userInput) => {
      const input = userInput.toLowerCase().trim();
      
      // Check for thank you - auto end call
      if (input.match(/\b(thank you|thanks|thank|cheers|appreciate)\b/)) {
        stopListening();
        return "Thank you for choosing MML Restaurant! Your reservation is confirmed. We look forward to serving you. Have a wonderful day! Goodbye!";
      }
      
      // ENHANCED: Check if this is a complete reservation in one paragraph
      // Look for multiple booking elements in a single input
      const hasMultipleElements = (
        (extractName(input) !== null) + 
        (extractDate(input) !== null) + 
        (extractTime(input) !== null) + 
        (extractMembers(input) !== null)
      ) >= 3; // If 3 or more elements are present, treat as complete reservation
      
      // Check for booking keywords that suggest complete reservation intent
      const hasBookingIntent = input.match(/\b(book|reserve|reservation|table|dinner|lunch)\b/) && 
                              (input.length > 50 || hasMultipleElements);
      
      if ((reservationStep <= RESERVATION_STEPS.NAME || reservationStep === RESERVATION_STEPS.GREETING) && 
          (hasMultipleElements || hasBookingIntent)) {
        
        console.log('üöÄ Detected complete reservation attempt - extracting all details...');
        const completeData = extractCompleteReservation(userInput);
        
        // Count how many fields we successfully extracted
        const extractedFields = Object.values(completeData).filter(value => value !== null).length;
        
        if (extractedFields >= 3) {
          // We have enough information - populate customerData
          Object.assign(customerData, completeData);
          
          // Set default special requests if none provided
          if (!customerData.specialRequests) {
            customerData.specialRequests = "No special requests";
          }
          
          // Show confirmation modal immediately
          showConfirmationModal(customerData);
          reservationStep = RESERVATION_STEPS.CONFIRMATION;
          
          console.log('‚úÖ Complete reservation processed - showing confirmation modal');
          
          return `Perfect! I understood your complete reservation request. Let me confirm the details: 
                   ${customerData.name ? `Name: ${customerData.name}` : 'Name: Please confirm'}, 
                   ${customerData.date ? `Date: ${customerData.date}` : 'Date: Please confirm'}, 
                   ${customerData.time ? `Time: ${customerData.time}` : 'Time: Please confirm'}, 
                   ${customerData.members ? `Party size: ${customerData.members}` : 'Party size: Please confirm'}.
                   Please review the confirmation window and click 'Confirm Reservation' if everything looks correct, or 'Edit Details' to make changes.`;
        } else {
          // Not enough information - ask for missing details
          const missingFields = [];
          if (!completeData.name) missingFields.push('name');
          if (!completeData.date) missingFields.push('date');
          if (!completeData.time) missingFields.push('time');  
          if (!completeData.members) missingFields.push('party size');
          
          // Populate what we have and continue with normal flow
          Object.assign(customerData, completeData);
          
          if (!customerData.name) {
            reservationStep = RESERVATION_STEPS.NAME;
            return `I caught some of your reservation details! However, I need your name to proceed. Could you please tell me your name?`;
          } else if (!customerData.date) {
            reservationStep = RESERVATION_STEPS.DATE;
            return `Great, ${customerData.name}! I have your name. What date would you like for your reservation?`;
          } else if (!customerData.time) {
            reservationStep = RESERVATION_STEPS.TIME;
            return `Perfect ${customerData.name}, for ${customerData.date}. What time would you prefer?`;
          } else if (!customerData.members) {
            reservationStep = RESERVATION_STEPS.MEMBERS;
            return `Excellent ${customerData.name}, for ${customerData.date} at ${customerData.time}. How many people will be dining?`;
          }
        }
      }
      
      // Handle based on current reservation step (ORIGINAL STEP-BY-STEP FLOW)
      switch (reservationStep) {
        case RESERVATION_STEPS.GREETING:
          reservationStep = RESERVATION_STEPS.NAME;
          return "Hello and welcome to MML Restaurant! I'm your voice reservation assistant. You can tell me all your details at once like 'Book a table for John Smith, tomorrow at 7 PM for 4 people' or I can guide you step by step. How would you like to proceed?";
          
        case RESERVATION_STEPS.NAME:
          const extractedName = extractName(input);
          if (extractedName) {
            customerData.name = extractedName;
            reservationStep = RESERVATION_STEPS.DATE;
            return `Perfect, ${extractedName}! Now, what date would you like to make your reservation? You can say today, tomorrow, or a specific date.`;
          } else {
            return "I didn't catch your name clearly. Could you please tell me your name again?";
          }
          
        case RESERVATION_STEPS.DATE:
          const extractedDate = extractDate(input);
          if (extractedDate) {
            customerData.date = extractedDate;
            reservationStep = RESERVATION_STEPS.TIME;
            return `Great! ${extractedDate} it is. What time would you prefer for your reservation? We're open from 5 PM to 11 PM.`;
          } else {
            return "I'd love to help you with any date! Could you please tell me what date you'd like to dine with us? You can say today, tomorrow, May 19, April 20, or any date you prefer.";
          }
          
        case RESERVATION_STEPS.TIME:
          const extractedTime = extractTime(input);
          if (extractedTime) {
            customerData.time = extractedTime;
            reservationStep = RESERVATION_STEPS.MEMBERS;
            return `Excellent! ${extractedTime} on ${customerData.date}. How many people will be joining you for dinner?`;
          } else {
            return "I can accommodate any time! What time works best for you? You can say 7 PM, 7.0 p.m., seven o'clock, or any time you prefer.";
          }
          
        case RESERVATION_STEPS.MEMBERS:
          const extractedMembers = extractMembers(input);
          if (extractedMembers) {
            customerData.members = extractedMembers;
            reservationStep = RESERVATION_STEPS.SPECIAL_REQUESTS;
            return `Perfect! Table for ${extractedMembers} people. Do you have any special requests? Perhaps dietary requirements, celebrating a special occasion, or preference for seating?`;
          } else {
            return "I didn't get the number of people. How many members will be dining with you?";
          }
          
        case RESERVATION_STEPS.SPECIAL_REQUESTS:
          customerData.specialRequests = input || "No special requests";
          
          // Show visual confirmation modal instead of verbal confirmation
          showConfirmationModal(customerData);
          reservationStep = RESERVATION_STEPS.CONFIRMATION;
          
          return null; // Don't speak anything - modal will handle the interaction
          
        case RESERVATION_STEPS.CONFIRMATION:
          // This case is now handled by the modal buttons
          // But we keep it for voice commands if modal is dismissed
          if (input.match(/\b(yes|correct|right|confirm|ok|okay|sure)\b/)) {
            handleFinalConfirmation();
            return null; // Message handled by handleFinalConfirmation
          } else if (input.match(/\b(no|wrong|change|modify|edit)\b/)) {
            handleEditReservation();
            return null; // Message handled by handleEditReservation
          } else {
            return "I see the confirmation window is open. Please click 'Confirm Reservation' to proceed or 'Edit Details' to make changes. You can also say 'yes' to confirm or 'no' to edit.";
          }
          
        case RESERVATION_STEPS.COMPLETE:
          if (input.match(/\b(bye|goodbye|no|nothing)\b/)) {
            stopListening();
            return "Thank you for choosing MML Restaurant! Have a wonderful day and we'll see you soon!";
          } else {
            return "How else can I assist you with your reservation today?";
          }
          
        default:
          reservationStep = RESERVATION_STEPS.GREETING;
          return "Welcome to MML Restaurant! You can say all your reservation details at once, like 'I'd like to book a table for Sarah Johnson tomorrow at 7 PM for 2 people' or I can guide you step by step. How would you like to proceed?";
      }
    };

    // Extract name from user input
    function extractName(input) {
      // Normalize input
      const cleanInput = input.trim().replace(/\s+/g, ' ');
      // Enhanced patterns for name extraction
      const namePatterns = [
        /(?:my name is|i'm|i am|hi i am|hi i'm|hello i am|hello i'm|this is|call me|name's|under the name|name)\s+([a-zA-Z][a-zA-Z\s]{1,30})/i,
        /(?:reservation for|table for|booking for)\s+([a-zA-Z][a-zA-Z\s]{1,30})(?:\s+(?:on|at|for|today|tomorrow))/i,
        /^([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2})(?:\s+(?:would like|wants|needs|for))/i
      ];
      for (const pattern of namePatterns) {
        const match = cleanInput.match(pattern);
        if (match) {
          const potentialName = match[1].trim();
          if (!potentialName.match(/\b(reservation|table|book|today|tomorrow|restaurant|want|need|time|date|people|person|dinner|lunch)\b/i) && potentialName.length >= 2) {
            return potentialName;
          }
        }
      }
      // Fallback: try to find a capitalized name after greeting
      const fallbackPattern = /(?:hi|hello|hey)[,\s]+([A-Z][a-z]+(?:\s+[A-Z][a-z]+){0,2})/i;
      const fallbackMatch = cleanInput.match(fallbackPattern);
      if (fallbackMatch) {
        return fallbackMatch[1].trim();
      }
      return null;
    }

    // Extract date from user input - Enhanced to accept any date format
    function extractDate(input) {
      const cleanInput = input.toLowerCase().replace(/[^\w\s]/g, ' ').trim();
      
      // Immediate date keywords
      if (cleanInput.match(/\b(today|now)\b/)) return 'Today';
      if (cleanInput.match(/\b(tomorrow|tmrw)\b/)) return 'Tomorrow';
      if (cleanInput.match(/\b(day after tomorrow)\b/)) return 'Day After Tomorrow';
      
      // Days of the week
      const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
      for (const day of days) {
        if (cleanInput.includes(day.substring(0, 3)) || cleanInput.includes(day)) {
          return day.charAt(0).toUpperCase() + day.slice(1);
        }
      }
      
      // Month names with dates - Enhanced to accept any month/day combination
      const months = {
        'january': 'January', 'jan': 'January',
        'february': 'February', 'feb': 'February', 
        'march': 'March', 'mar': 'March',
        'april': 'April', 'apr': 'April',
        'may': 'May',
        'june': 'June', 'jun': 'June',
        'july': 'July', 'jul': 'July',
        'august': 'August', 'aug': 'August',
        'september': 'September', 'sep': 'September', 'sept': 'September',
        'october': 'October', 'oct': 'October',
        'november': 'November', 'nov': 'November',
        'december': 'December', 'dec': 'December'
      };
      
      // Look for month + day patterns (like "may 19", "april 20")
      for (const [monthKey, monthName] of Object.entries(months)) {
        const monthDayPattern = new RegExp(`\\b${monthKey}\\s+(\\d{1,2})(?:st|nd|rd|th)?\\b`, 'i');
        const dayMonthPattern = new RegExp(`\\b(\\d{1,2})(?:st|nd|rd|th)?\\s+${monthKey}\\b`, 'i');
        
        let match = cleanInput.match(monthDayPattern) || cleanInput.match(dayMonthPattern);
        if (match) {
          const day = match[1];
          return `${monthName} ${day}`;
        }
      }
      
      // Flexible date patterns - Accept any reasonable date format
      const datePatterns = [
        /\b(\d{1,2})[\/\-](\d{1,2})(?:[\/\-](\d{2,4}))?\b/, // 12/25, 12-25, 12/25/2024
        /\b(\d{1,2})(?:st|nd|rd|th)\b/,                     // 19th, 20th, 1st
        /\b(\d{4})[\/\-](\d{1,2})[\/\-](\d{1,2})\b/        // 2024/12/25
      ];
      
      for (const pattern of datePatterns) {
        const match = cleanInput.match(pattern);
        if (match) {
          return match[0].replace(/st|nd|rd|th/g, ''); // Clean up ordinals
        }
      }
      
      // If nothing else matches, accept anything that looks like a date
      // This makes the system very permissive
      const anyDatePattern = /\b\d{1,2}[\s\-\/]\w+|\w+[\s\-\/]\d{1,2}\b/;
      const anyMatch = cleanInput.match(anyDatePattern);
      if (anyMatch) {
        return anyMatch[0];
      }
      
      return null;
    }

    // Extract time from user input - Enhanced to accept any time format
    function extractTime(input) {
      const cleanInput = input.toLowerCase().replace(/[^\w\s:\.]/g, ' ').trim();
      
      // Enhanced time patterns - Accept many formats
      const timePatterns = [
        // Standard formats
        /\b(\d{1,2}):(\d{1,2})\s*(pm|am|p\.?m\.?|a\.?m\.?)\b/i,  // 7:30 PM, 7:30 p.m.
        /\b(\d{1,2})\s*(pm|am|p\.?m\.?|a\.?m\.?)\b/i,            // 7 PM, 7 p.m.
        /\b(\d{1,2}):(\d{1,2})\b/,                               // 7:30 (assume PM for restaurant)
        
        // Decimal formats like "7.0 p.m"
        /\b(\d{1,2})\.(\d{1,2})\s*(pm|am|p\.?m\.?|a\.?m\.?)\b/i, // 7.0 PM, 7.30 p.m.
        /\b(\d{1,2})\.(\d{1,2})\b/,                              // 7.0, 7.30
        
        // Special times
        /\b(noon|midday)\b/i,                                    // noon, midday
        /\b(midnight)\b/i,                                       // midnight
        
        // Time with words
        /\b(\d{1,2})\s*(?:o'?clock|oclock|clock)\b/i,           // 7 o'clock, 7 oclock
        /\b(half past|thirty past)\s+(\d{1,2})\b/i,             // half past 7
        /\b(\d{1,2})\s+(thirty|half)\b/i,                       // 7 thirty, 7 half
        /\b(quarter past|fifteen past)\s+(\d{1,2})\b/i,         // quarter past 7
        /\b(\d{1,2})\s+(fifteen|quarter)\b/i                    // 7 fifteen, 7 quarter
      ];
      
      for (const pattern of timePatterns) {
        const match = cleanInput.match(pattern);
        if (match) {
          let hour, minute = '00', period = '';
          
          // Handle special cases
          if (match[0].includes('noon') || match[0].includes('midday')) {
            return '12:00 PM';
          }
          if (match[0].includes('midnight')) {
            return '12:00 AM';
          }
          
          // Handle half past, thirty
          if (match[0].includes('half') || match[0].includes('thirty')) {
            hour = match[2] || match[1];
            minute = '30';
          }
          // Handle quarter past, fifteen
          else if (match[0].includes('quarter') || match[0].includes('fifteen')) {
            hour = match[2] || match[1];
            minute = '15';
          }
          // Handle regular formats
          else {
            hour = match[1];
            minute = match[2] || '00';
            period = match[3] || '';
          }
          
          // Convert to numbers for validation
          const hourNum = parseInt(hour);
          let minuteNum = parseInt(minute);
          
          // Validate hour and minute
          if (hourNum >= 1 && hourNum <= 12 && minuteNum >= 0 && minuteNum <= 59) {
            // Auto-detect PM for restaurant hours if no period specified
            if (!period) {
              period = 'PM'; // Default to PM for restaurant bookings
            }
            
            // Format the time nicely
            const formattedHour = hourNum.toString();
            const formattedMinute = minuteNum.toString().padStart(2, '0');
            let formattedPeriod = period.replace(/\./g, '').toUpperCase();
            
            return `${formattedHour}:${formattedMinute} ${formattedPeriod}`;
          }
        }
      }
      
      // Word-based times - Enhanced with more options
      const wordTimes = {
        // Numbers as words
        'one': '1:00 PM', 'two': '2:00 PM', 'three': '3:00 PM', 'four': '4:00 PM',
        'five': '5:00 PM', 'six': '6:00 PM', 'seven': '7:00 PM', 'eight': '8:00 PM', 
        'nine': '9:00 PM', 'ten': '10:00 PM', 'eleven': '11:00 PM', 'twelve': '12:00 PM',
        
        // Time-related words
        'lunch': '12:00 PM', 'lunchtime': '12:00 PM',
        'dinner': '7:00 PM', 'dinnertime': '7:00 PM',
        'evening': '7:00 PM', 'early evening': '6:00 PM', 'late evening': '8:00 PM',
        'afternoon': '2:00 PM', 'early afternoon': '1:00 PM', 'late afternoon': '4:00 PM',
        
        // Combined formats
        'five thirty': '5:30 PM', 'six thirty': '6:30 PM', 'seven thirty': '7:30 PM',
        'eight thirty': '8:30 PM', 'nine thirty': '9:30 PM', 'ten thirty': '10:30 PM'
      };
      
      // Check for word-based times
      for (const [phrase, time] of Object.entries(wordTimes)) {
        if (cleanInput.includes(phrase)) {
          return time;
        }
      }
      
      // Very permissive fallback - if we see any number, try to make it a time
      const numberMatch = cleanInput.match(/\b(\d{1,2})\b/);
      if (numberMatch) {
        const num = parseInt(numberMatch[1]);
        if (num >= 1 && num <= 12) {
          return `${num}:00 PM`; // Default to PM for restaurant
        }
      }
      
      return null;
    }

    // Extract number of members - ENHANCED for one-paragraph input
    function extractMembers(input) {
      const cleanInput = input.toLowerCase();
      
      // Enhanced patterns for one-paragraph extraction
      const memberPatterns = [
        // Standard patterns
        /(?:table for|party of|for)\s+(\d+)(?:\s+(?:people|persons|guests|members|pax))?/i,
        /(\d+)\s+(?:people|persons|guests|members|pax)/i,
        /(?:we are|there are|group of)\s+(\d+)/i,
        /(\d+)\s+(?:of us|in our party|in our group)/i,
        
        // Word numbers
        /(?:table for|party of|for)\s+(one|two|three|four|five|six|seven|eight|nine|ten)(?:\s+(?:people|persons|guests))?/i,
        /(one|two|three|four|five|six|seven|eight|nine|ten)\s+(?:people|persons|guests|members)/i,
        
        // Context-aware patterns for complete reservations
        /(?:reservation|booking).*?(?:for|party of)\s+(\d+)/i,
        /(?:dinner|lunch).*?(?:for|party of)\s+(\d+)/i,
        /\b(\d+)\s*(?:-person|person)/i
      ];
      
      for (const pattern of memberPatterns) {
        const match = cleanInput.match(pattern);
        if (match) {
          let members = match[1];
          
          // Convert word numbers to digits
          const wordToNumber = {
            'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
            'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10
          };
          
          if (wordToNumber[members.toLowerCase()]) {
            members = wordToNumber[members.toLowerCase()];
          } else {
            members = parseInt(members);
          }
          
          if (members >= 1 && members <= 20) {
            return members;
          }
        }
      }
      
      // Fallback: look for any reasonable number in context
      const contextPattern = /\b(\d)\s*(?=\s*(?:people|person|guests|members|pax|us|diners))/i;
      const contextMatch = cleanInput.match(contextPattern);
      if (contextMatch) {
        const num = parseInt(contextMatch[1]);
        if (num >= 1 && num <= 12) {
          return num;
        }
      }
      
      return null;
    }

    // ENHANCED Speech Recognition Setup - Crystal Clear Voice & Continuous Listening
    const setupSpeechRecognition = () => {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      
      if (!SpeechRecognition) {
        log("‚ùå Speech recognition not supported. Please use Chrome, Edge, or Safari.", false);
        const statusEl = document.getElementById('status');
        if (statusEl) {
          statusEl.textContent = 'Speech recognition not supported - please use Chrome or Edge browser';
        }
        return null;
      }
      
      try {
        recognition = new SpeechRecognition();
        
        // ENHANCED settings for CRYSTAL CLEAR voice recognition
        recognition.lang = "en-US";
        recognition.interimResults = true;     // Show partial results for better UX
        recognition.maxAlternatives = 5;       // More alternatives for better accuracy
        recognition.continuous = true;         // CONTINUOUS listening - no interruptions
        
        // ADVANCED audio settings for better voice clarity
        if (recognition.serviceURI) {
          recognition.serviceURI = 'wss://www.google.com/speech-api/v2/recognize';
        }
        
        // Auto-restart on silence - NEVER STOP LISTENING
        let restartTimeout;
        let isFirstStart = true;
        
        recognition.onstart = () => {
          console.log('üé§ ENHANCED Speech recognition started - Crystal Clear Mode');
          const statusEl = document.getElementById('status');
          if (statusEl) {
            if (isFirstStart) {
              statusEl.textContent = 'üéß MML Restaurant is listening! Speak naturally and clearly...';
              isFirstStart = false;
            } else {
              statusEl.textContent = 'üéß Ready to hear you - Please continue speaking...';
            }
            statusEl.className = 'status listening';
          }
          
          // Clear any restart timeout
          if (restartTimeout) {
            clearTimeout(restartTimeout);
          }
        };
        
        recognition.onresult = (event) => {
          try {
            let finalTranscript = '';
            let interimTranscript = '';
            let confidence = 0;
            
            // Process all results with ENHANCED accuracy checking
            for (let i = event.resultIndex; i < event.results.length; i++) {
              const result = event.results[i];
              const transcript = result[0].transcript;
              confidence = Math.max(confidence, result[0].confidence || 0.8);
              
              if (result.isFinal) {
                finalTranscript += transcript;
              } else {
                interimTranscript += transcript;
              }
            }
            
            // ENHANCED interim feedback - show what we're hearing
            if (interimTranscript.trim()) {
              const statusEl = document.getElementById('status');
              if (statusEl) {
                statusEl.textContent = `üéß Hearing: "${interimTranscript.trim()}" (${Math.round(confidence * 100)}% confident)`;
                statusEl.className = 'status listening';
              }
            }
            
            // Process FINAL result with confidence checking
            if (finalTranscript.trim()) {
              const cleanTranscript = finalTranscript.trim();
              console.log(`Final transcript (${Math.round(confidence * 100)}% confidence):`, cleanTranscript);
              
              // Log with confidence indicator
              log(`${cleanTranscript} ${confidence > 0.7 ? '‚úÖ' : '‚ö†Ô∏è'}`, true);
              
              // IMMEDIATE processing - no delays
              processVoiceInput(cleanTranscript, confidence);
            }
            
          } catch (error) {
            console.error('Error processing speech result:', error);
            log('Voice processing error - please try speaking again.', false);
          }
        };
        
        // ENHANCED error handling - AUTO-RETRY on any issue
        recognition.onerror = (event) => {
          console.error('Speech recognition error:', event.error);
          
          let errorMessage = '';
          let shouldRetry = true;
          
          switch(event.error) {
            case 'no-speech':
              errorMessage = 'ü§´ Listening... Please speak when ready';
              break;
            case 'audio-capture':
              errorMessage = 'üé§ Microphone issue - checking audio...';
              shouldRetry = false;
              break;
            case 'not-allowed':
              errorMessage = 'üö´ Please allow microphone access for voice booking';
              shouldRetry = false;
              break;
            case 'network':
              errorMessage = 'üåê Network error. Please check your internet connection.';
              break;
            case 'service-not-allowed':
              errorMessage = '‚ùå Speech service not available. Try refreshing the page.';
              break;
            case 'bad-grammar':
              errorMessage = 'üîÑ Having trouble understanding. Try speaking more clearly.';
              break;
            case 'language-not-supported':
              errorMessage = 'üåç Language not supported. Using English...';
              break;
            default:
              errorMessage = `‚ùå Speech error: ${event.error}. Trying again...`;
          }
          
          const statusEl = document.getElementById('status');
          if (statusEl) {
            statusEl.textContent = errorMessage;
            statusEl.className = 'status';
          }
          
          // Retry listening after a short delay
          if (shouldRetry && isListening) {
            setTimeout(() => {
              if (isListening) {
                const statusEl = document.getElementById('status');
                if (statusEl) {
                  statusEl.textContent = 'üîÑ Restarting speech recognition...';
                }
                startListening();
              }
            }, 500);
          } else if (!shouldRetry) {
            stopListening();
          }
        };
        
        // CONTINUOUS listening - AUTO-RESTART always
        recognition.onend = () => {
          console.log('üîö Speech recognition ended - AUTO-RESTARTING...');
          if (isListening) {
            // IMMEDIATE restart - no delays for continuous listening
            restartTimeout = setTimeout(() => {
              if (isListening) {
                console.log('üîÑ Auto-restarting recognition for continuous listening');
                try {
                  recognition.start();
                } catch (e) {
                  console.log('Recognition restart handled automatically');
                }
              }
            }, 100); // Very fast restart
          }
        };
        
        return recognition;
        
      } catch (error) {
        console.error('Failed to setup speech recognition:', error);
        log('‚ùå Failed to setup speech recognition. Please refresh the page and try again.', false);
        return null;
      }
    };

    // NEW: Process voice input with confidence scoring
    function processVoiceInput(transcript, confidence = 1.0) {
      // Don't process if confidence is too low
      if (confidence < 0.3) {
        log('‚ö†Ô∏è Speech not clear enough, please repeat', false);
        return;
      }
      
      // Check for thank you - auto end call
      if (transcript.toLowerCase().match(/\b(thank you|thanks|thank|cheers|appreciate)\b/)) {
        stopListening();
        speakClearly("Thank you for choosing MML Restaurant! Your reservation is confirmed. We look forward to serving you. Have a wonderful day! Goodbye!");
        return;
      }
      
      // Generate AI response with enhanced clarity
      const aiResponse = generateAIResponse(transcript);
      
      // Extracted name confirmation
      const extractedName = extractName(transcript);
      if (extractedName) {
        log(`üë§ Name detected: <strong>${extractedName}</strong>`, false);
        customerData.name = extractedName;
      }
      
      // Only log and speak if there's a response (null means modal is handling interaction)
      if (aiResponse !== null && aiResponse !== undefined && aiResponse !== '') {
        log(aiResponse, false);
        speakClearly(aiResponse);
      }
    }

    // Enhanced start listening function with microphone test
    const startListening = () => {
      if (!recognition) {
        console.error('Speech recognition not initialized');
        log('‚ùå Speech recognition not available. Please refresh the page.', false);
        return;
      }
      
      if (!isListening) {
        return; // Don't start if we shouldn't be listening
      }
      
      // Test microphone access first
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(() => {
         
          console.log('‚úÖ Microphone access granted');
          
          try {
            // Stop any existing recognition
            try {
              recognition.stop();
            } catch (e) {
              // Ignore stop errors
            }
            
            // Start recognition
            recognition.start();
            console.log('üé§ Starting speech recognition...');
            
          } catch (error) {
            console.error('Recognition start error:', error);
            
            if (error.name === 'InvalidStateError') {
              // Recognition is already running, just update status
              console.log('Recognition already running');
              const statusEl = document.getElementById('status');
              if (statusEl) {
                statusEl.textContent = 'üéß Already listening... Please speak!';
                statusEl.className = 'status listening';
              }
            } else {
              const statusEl = document.getElementById('status');
              if (statusEl) {
                statusEl.textContent = '‚ùå Could not start listening. Try again.';
                statusEl.className = 'status';
              }
              
              // Try to restart after a delay
              if (isListening) {
                setTimeout(() => {
                  if (isListening) {
                    console.log('Retrying speech recognition...');
                    startListening();
                  }
                }, 500);
              }
            }
          }
        })
        .catch((error) => {
          console.error('Microphone access error:', error);
          const statusEl = document.getElementById('status');
          if (statusEl) {
            if (error.name === 'NotAllowedError') {
              statusEl.textContent = 'üö´ Microphone access denied. Please allow microphone access and refresh the page.';
              log('To fix microphone access: Click the üîí lock icon in your browser address bar, allow microphone access, then refresh the page.', false);
            } else if (error.name === 'NotFoundError') {
              statusEl.textContent = 'üé§ No microphone found. Please connect a microphone and try again.';
            } else {
              statusEl.textContent = `üé§ Microphone error: ${error.message}`;
            }
            statusEl.className = 'status';
          }
          stopListening();
        });
    };

    // Test microphone functionality
    async function testMicrophone() {
      const statusEl = document.getElementById('status');
      if (statusEl) {
        statusEl.textContent = 'üé§ Testing microphone...';
        statusEl.className = 'status';
      }
      
      try {
        // Request microphone permission
        const stream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });
        
        log('‚úÖ Microphone access granted! Now testing speech recognition...', false);
        
        if (statusEl) {
          statusEl.textContent = '‚úÖ Microphone working! Testing speech recognition...';
          statusEl.className = 'status listening';
        }
        
        // Test speech recognition
        if (!recognition) {
          setupSpeechRecognition();
        }
        
        if (recognition) {
          let testCompleted = false;
          
          const timeout = setTimeout(() => {
            if (!testCompleted) {
              recognition.stop();
              if (statusEl) {
                statusEl.textContent = '‚è∞ Speech test timeout. Your microphone works, but try speaking louder.';
                statusEl.className = 'status';
              }
              log('Speech recognition test timed out. Your microphone is working, but speech recognition may need adjustment.', false);
            }
          }, 5000);
          
          recognition.onresult = (event) => {
            testCompleted = true;
            clearTimeout(timeout);
            const transcript = event.results[0][0].transcript;
            log(`‚úÖ Microphone test successful! I heard: "${transcript}"`, false);
            
            if (statusEl) {
              statusEl.textContent = '‚úÖ Perfect! Your microphone and speech recognition are working!';
              statusEl.className = 'status';
            }
            
            recognition.stop();
          };
          
          recognition.onerror = (event) => {
            testCompleted = true;
            clearTimeout(timeout);
            console.error('Speech recognition test error:', event.error);
            
            if (statusEl) {
              statusEl.textContent = `‚ùå Speech test failed: ${event.error}. Your microphone works but speech recognition has issues.`;
              statusEl.className = 'status';
            }
            
            log(`Speech recognition test failed: ${event.error}. Your microphone is working, but there's a speech recognition issue.`, false);
          };
          
          if (statusEl) {
            statusEl.textContent = 'üéß Say "Hello" to test your microphone and speech recognition...';
            statusEl.className = 'status listening';
          }
          
          log('üéß Please say "Hello" to test your microphone and speech recognition...', false);
          recognition.start();
          
        } else {
          if (statusEl) {
            statusEl.textContent = '‚ùå Speech recognition not available';
            statusEl.className = 'status';
          }
          log('‚ùå Speech recognition could not be initialized', false);
        }
        
        // Stop the stream after test
        setTimeout(() => {
          stream.getTracks().forEach(track => track.stop());
        }, 10000);
        
      } catch (error) {
        console.error('Microphone test failed:', error);
        
        if (error.name === 'NotAllowedError') {
          if (statusEl) {
            statusEl.textContent = '‚ùå Microphone access denied. Please allow microphone access.';
            statusEl.className = 'status';
          }
          log('‚ùå Microphone access denied. To fix this:', false);
          log('1. Click the üîí lock icon in your browser address bar', false);
          log('2. Allow microphone access', false);
          log('3. Refresh the page and try again', false);
        } else if (error.name === 'NotFoundError') {
          if (statusEl) {
            statusEl.textContent = '‚ùå No microphone found. Please connect a microphone.';
            statusEl.className = 'status';
          }
          log('‚ùå No microphone detected. Please connect a microphone and try again.', false);
        } else {
          if (statusEl) {
            statusEl.textContent = `‚ùå Microphone test failed: ${error.message}`;
            statusEl.className = 'status';
          }
          log(`‚ùå Microphone test failed: ${error.message}`, false);
        }
      }
    }

    // Stop listening function
    const stopListening = () => {
      isListening = false;
      if (recognition) {
        recognition.stop();
      }
      document.getElementById('start').disabled = false;
      document.getElementById('stop').disabled = true;
      document.getElementById('status').textContent = 'Voice chat stopped';
      document.getElementById('status').className = 'status';
    };

    // Enhanced initialization
    document.addEventListener('DOMContentLoaded', () => {
      console.log('Initializing voice chat application...');
      
      // Test browser compatibility
      if (!('speechSynthesis' in window)) {
        log('‚ö†Ô∏è Text-to-speech not supported in this browser', false);
      }
      
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        log('‚ö†Ô∏è Speech recognition not supported. Please use Chrome, Edge, or Safari.', false);
        document.getElementById('start').disabled = true;
        return;
      }
      
      // Setup speech recognition
      try {
        setupSpeechRecognition();
        if (recognition) {
          log('‚úÖ MML Restaurant booking system ready! Click "Make Reservation" to begin.', false);
          
          // üîÑ Sync any offline reservations to MongoDB
          syncOfflineReservations();
        } else {
          log('‚ùå Failed to initialize speech recognition.', false);
          document.getElementById('start').disabled = true;
        }
      } catch (error) {
        console.error('Initialization error:', error);
        log('‚ùå Initialization failed. Please refresh the page.', false);
        document.getElementById('start').disabled = true;
      }
      
      // Button event listeners with error handling
      document.getElementById('micTest').onclick = () => {
        testMicrophone();
      };
      
      document.getElementById('testVoice').onclick = () => {
        testSelectedVoice();
      };
      
      // Confirmation Modal Button Event Listeners
      document.getElementById('finalConfirm').onclick = () => {
        handleFinalConfirmation();
      };
      
      document.getElementById('editReservation').onclick = () => {
        handleEditReservation();
      };
      
      // Close modal when clicking outside
      document.getElementById('confirmationModal').onclick = (e) => {
        if (e.target.id === 'confirmationModal') {
          // Don't close automatically - require explicit action
          speakClearly("Please click 'Confirm Reservation' to proceed or 'Edit Details' to make changes.");
        }
      };
      
      document.getElementById('start').onclick = async () => {
        try {
          // STEP 1: Auto-request microphone permission
          const statusEl = document.getElementById('status');
          if (statusEl) {
            statusEl.textContent = 'üé§ Requesting microphone access for crystal clear conversation...';
            statusEl.className = 'status';
          }
          
          // Request microphone permission immediately
          await navigator.mediaDevices.getUserMedia({ 
            audio: {
              echoCancellation: true,    // Remove echo
              noiseSuppression: true,    // Remove background noise  
              autoGainControl: true,     // Auto-adjust volume
              channelCount: 1,           // Mono for clarity
              sampleRate: 44100          // High quality sample rate
            }
          });
          
          if (statusEl) {
            statusEl.textContent = '‚úÖ Microphone access granted! Setting up crystal clear voice recognition...';
            statusEl.className = 'status listening';
          }
          
          // STEP 2: Initialize enhanced speech recognition
          if (!recognition) {
            recognition = setupSpeechRecognition();
            if (!recognition) {
              log('‚ùå Could not initialize speech recognition.', false);
              return;
            }
          }
          
          // STEP 3: Start the enhanced booking system
          isListening = true;
          document.getElementById('start').disabled = true;
          document.getElementById('stop').disabled = false;
          
          if (statusEl) {
            statusEl.textContent = 'üéß MML Restaurant is ready to take your reservation!';
            statusEl.className = 'status listening';
          }
          
          log("üé§ Crystal clear voice booking started!", false);
          
          // Start with enhanced clarity and immediate listening
          speakClearly("Hello and welcome to MML Restaurant! I'm your voice reservation assistant. To book your table, may I please have your name?");
          
          // Initialize reservation system
          reservationStep = RESERVATION_STEPS.NAME;
          
        } catch (error) {
          console.error('Start button error:', error);
          
          const statusEl = document.getElementById('status');
          if (error.name === 'NotAllowedError') {
            log('‚ùå Microphone access denied. Please click the üîí icon in your address bar and allow microphone access.', false);
            if (statusEl) {
              statusEl.textContent = 'üö´ Please allow microphone access to make your reservation';
              statusEl.className = 'status';
            }
          } else {
            log('‚ùå Failed to start voice booking. Please try again.', false);
            if (statusEl) {
              statusEl.textContent = '‚ùå Voice booking failed - please try again';
              statusEl.className = 'status';
            }
          }
          
          isListening = false;
          document.getElementById('start').disabled = false;
          document.getElementById('stop').disabled = true;
        }
      };
      
      document.getElementById('stop').onclick = () => {
        try {
          stopListening();
        } catch (error) {
          console.error('Stop button error:', error);
          // Force stop
          isListening = false;
          document.getElementById('start').disabled = false;
          document.getElementById('stop').disabled = true;
          const statusEl = document.getElementById('status');
          if (statusEl) {
            statusEl.textContent = 'Voice chat stopped';
            statusEl.className = 'status';
          }
        }
      };
      
      document.getElementById('clear').onclick = () => {
        try {
          const logEl = document.getElementById('log');
          if (logEl) {
            logEl.innerHTML = '';
          }
          conversationHistory = [];
          // Reset reservation system
          reservationStep = RESERVATION_STEPS.GREETING;
          customerData = { name: null, date: null, time: null, members: null, specialRequests: null, paymentStatus: 'Pending' };
          log("Chat cleared! Ready for a new reservation.", false);
        } catch (error) {
          console.error('Clear button error:', error);
        }
      };
    });

    // Handle page visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && isListening) {
        stopListening();
      }
    });
  </script>
</body>
</html>
